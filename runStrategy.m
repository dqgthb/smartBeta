%% Do not forget to read README.md!
%% Do not forget to read README.md!
%% Do not forget to read README.md!
%% Do not forget to read README.md!
%% Do not forget to read README.md!

function [] = runStrategy(strategyNo, crsp, thisCrsps, transactionCost)
% Function: runStrategy
% Author: Deon, Pegah, Jaskrit
% Last Modified: 2017-11-29
% Course: Applied Quantitative Finance Fall 2017 Section 1
% Project: Smart Beta (Assignment 3)
% Team name: Dexter
% Function description:
    % This is a simple modification of runSampleStrategy.m file that Evan provided us.
    % Things that are modified:
        % - runSampleStrategy.m was a Script file, but now it is transformed into a function file, which allows us to use this in 'main.m' for automation.
        % - Some disp, fprintf function lines to specify the progress of this function, because it takes some time to run (so the user may not be bored).
% Purpose:
    % To perform a specific strategy specified in the input argument with 'strategyNo' variable to all the dates of dataset, saves the transaction log in 'thisStrategy' variable and evaluate the performance, save the evaluation in 'thisPerformance' variable.

% Inputs:
    % - strategyNo : what strategy we are running. Used in switch-case statement below.
    % - crsp : the data file we are using. This is a large file and it takes time to load. Instead of loading a new crsp data everytime when running this function, we can import crsp file only for once in 'main.m' and pass this to 'runStrategy.m' as an argument.
    % - thisCrsps: this is a special table we created in order to significantly increase the performance of this code. By adding this variable we can improve the running time of this code from 3 minutes to 30 seconds. This table contains every single 'thisCrsp' generated by 'isInvestible' (from tradeLongMomentum.m) conditional statement for each datenum. Before using this table, the strategy functions (e.g. strategyMS_V, strategySM_V) should have calculated thisCrsp for all for-loop iterations, which took a significant amount of running time. Now we skip the process by providing every 'thisCrsp's as a function argument to the strategy functions.
        % - In case you are wondering 'what is thisCrsp?', check the tradeLongMomentum.m Evan provided us as an example. This is simply a crsp table with firms investible at a specific datenum.
% Outputs:

    fprintf("\n");
    disp("Program begins!")
    disp(datestr(now, 'HH:MM:SS')); % displays time when running this function.

    % clean up unnecessary variables, just for debugging purpose.
    clearvars -except crsp ff3 dateList marketIndex thisCrsps strategyNo transactionCost

    %% Input (function argument)
    % prints the values of 'strategyNo' and 'transactionCost', just for debugging purposes.
    fprintf("strategyNo : %d\n", strategyNo);
    fprintf("transactionCost : %d\n", transactionCost);

    % This is very similar to those if-statements explained in main.m. See 'main.m' for comparison.
    % These loads 'ff3', 'dateList' and 'marketIndex' variable from mat-files.
    % These are not included in 'main.m', because there is a trade-off in the design of the code.
    % If we include these 3 if-statements in 'main.m', the 'runStrategy.m' function will not recognize it so we should pass it as an argument. We only need to load it one time in that case, so we might expect some improvment on running time (i.e. getting read of loading time). However, this would lead us to a messy, long 'runStrategy' function with too many redundant arguments.
    % It turns out, however, the improvement on running time with 'ff3', 'dateList' and 'marketIndex' is insignificant and unrecognizable, unlike 'crsp' and 'thisCrsps'.
    % Therefore, in order to make the function cleaner, we included these 3 if-statements here, while including 'crsp' and 'thisCrsps' in 'main.m'.
    % It is true that all these messy considerations can be avoided if we use 'global variables', but this is based on our coding philosophy to maintain our code functional (i.e. the output of the code is always the same if the input is the same). We consider having states, especially while running data analysis, can be potentially very harmful and difficult to detect mistakes.
    %
    % checks if 'ff3' is in the workspace, and if not, load it to the workspace.
    if ~exist('ff3', 'var')
        fprintf("ff3 not exist. Loading...\n");
        ff3Mat = load('matFolder/ff3.mat');
        ff3 = ff3Mat.ff3;
    end
    % checks if 'dateList' is in the workspace, and if not, load it to the workspace.
    if ~exist('dateList', 'var')
        fprintf("dateList not exist. Loading...\n");
        dateListMat = load('matFolder/dateList.mat');
        dateList = dateListMat.dateList;
    end
    % checks if 'marketIndex' is in the workspace, and if not, load it to the workspace.
    if ~exist('marketIndex', 'var')
        fprintf("marketIndex not exist. Loading...\n");
        marketIndexMat = load('matFolder/marketIndex.mat');
        marketIndex = marketIndexMat.marketIndex;
    end

    %% Track strategy positions
    % create table with variable name being datenum for first column.
    thisStrategy=table(dateList,'VariableNames',{'datenum'});

    %Create empty column of cells for investment weight tables
    thisStrategy{:,'portfolio'}={NaN};

    %Create empty column of NaNs for ret
    thisStrategy{:,'ret'}=NaN;
    thisStrategy{:,'turnover'}=NaN;
    thisStrategy{:,'ret_net'}=NaN;

    fprintf("start iteration..\n");
    n = 0;
    len = size(thisStrategy,1);

    starti = 295;% starts from 295 because sigma is available from this date.

    % This forloop iterates through each date (unique datenum column), and performs the trade based on the selected strategy (determined by 'strategyNo' input in the switch-case statement below).
    for i = starti:len
        % shows a nice progress of forloop, not to bore the user.
        % code obtained from https://stackoverflow.com/questions/8825796/how-to-clear-the-last-line-in-the-command-window
        msg = sprintf('Processed: %d/%d', i, len);
        fprintf(repmat('\b', 1, n));
        fprintf(msg);
        n=numel(msg);
        % ends the progress bar code.

        thisDate=thisStrategy.datenum(i);
        if i ~= starti
            lastPortfolio=thisPortfolio;
        end

        % What is this 'switch-case' statement, in case you are wondering?
        % based on the value of strategyNo, the code chooses the case and runs the lines contained in the specific case.
        % See matlab's guide to switch-case statement for further information.
        % For explanation of each strategy, see the individual strategy function file (e.g. strategyMS_V.m, strategySM_V.m).
        switch strategyNo
            case 0 % This is from Evan's code. We are not going to run it.
                thisPortfolio = tradeLongMomentum();
            case 1
                thisPortfolio = strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.8 1], [0 0.2], [0.8 1]);
            case 2
                thisPortfolio = strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.9 1], [0 0.1], [0.9 1]);
            case 3
                thisPortfolio = strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [.75 1],[0 .25],[.75 1]);
            case 4
                thisPortfolio = strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.1 1], [0.1 1], [0.75 1]);
            case 5
                thisPortfolio = strategyM_VS(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.9 1], [0 .1], [.7 1]);
            case 6
                thisPortfolio = strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.9 1], [0.4 0.6], [0.75 1]);
            case 7
                thisPortfolio = strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.9 1], [0.75 1], [0.9 1]);
            case 8
                thisPortfolio = strategySM_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.9 1], [0.75 1], [0.9 1]);
            case 9
                thisPortfolio = strategySM_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.9 1], [0 0.25], [0.9 1]);
            case 10
                thisPortfolio = strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.9 1], [0 0.25], [0.9 1]);
            case 11
                thisPortfolio = reverse_strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [.75 1],[0 .25],[.75 1]);
            case 12
                thisPortfolio = strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.9 1], [.75 1], [0.75 1]);
            case 13
                thisPortfolio = strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.95 1], [0 0.05], [0.95 1]);
            case 14
                thisPortfolio = strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.6 1], [0 0.4], [0.6 1]);
            case 15
                thisPortfolio = strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.75 1], [0 0.1], [0.9 1]);
            case 16
                thisPortfolio = strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.5 1], [0 0.1], [0.9 1]);
            case 17
                thisPortfolio = strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.1 1], [0 0.1], [0.9 1]);
            case 18
                thisPortfolio = strategyMS_V(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0 1], [0 0.1], [0.9 1]);
            case 19 % pure momentum-size (loser)
                thisPortfolio = strategyMS(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0 .1], [0 0.1]);
            case 20 % pure momentum-size with increased mom range (loser)
                thisPortfolio = strategyMS(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0 .3], [0 0.1]);
            case 21 % pure momentum-size with increased size range (loser)
                thisPortfolio = strategyMS(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0 .1], [0 0.3]);
            case 22 % pure momentum-size (winner)
                thisPortfolio = strategyMS(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.9 1], [0 0.1]);
            case 23 % pure momentum-size with increased mom range (winner)
                thisPortfolio = strategyMS(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.7 1], [0 0.1]);
            case 24 % pure momentum-size with increased size range (winner)
                thisPortfolio = strategyMS(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.9 1], [0 0.3]);
            case 25 % pure value (winner)
                thisPortfolio = strategyV(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.9 1]);
            case 26 % pure value (winner)
                thisPortfolio = strategyV(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0.7 1]);
            case 27 % pure value (loser)
                thisPortfolio = strategyV(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0 .1]);
            case 28 % pure value (loser)
                thisPortfolio = strategyV(thisCrsps.thisCrsp{i}, marketIndex.sigma(i), [0 .3]);

            otherwise
                disp("wrong strategy number!");
        end

        thisStrategy.portfolio(i)={thisPortfolio}; %Bubble wrap the table of investment weights and store in thisStrategy

        if(i ~= starti) % This part will run from the second iteration.
            if (sum(~isnan(thisPortfolio.w))>0)
                %Calculate returns if there's at least one valid position
                thisStrategy.ret(i)=nansum(thisPortfolio.RET.*thisPortfolio.w);

                changePortfolio=outerjoin(thisPortfolio(:,{'PERMNO','w'}),lastPortfolio(:,{'PERMNO','w'}),'Keys','PERMNO');
                %Fill missing positions with zeros
                changePortfolio=fillmissing( changePortfolio,'constant',0);
                thisStrategy.turnover(i)=nansum(abs(changePortfolio.w_left-changePortfolio.w_right))/2;
                % substract transaction cost
                thisStrategy.ret(i) = thisStrategy.ret(i) - transactionCost * thisStrategy.turnover(i);
            end
        end
    end
    fprintf("\nmaking 'thisStrategy' Done! Now evaluating...\n");
    disp(datestr(now, 'HH:MM:SS'));

    % Now that we have thisStrategy, we are going to evaluate it using evaluateStrategy.m function.
    thisPerformance = evaluateStrategy(thisStrategy,ff3);
    fprintf("Evaluation Done! Now saving the results ...\n");
    disp(datestr(now, 'HH:MM:SS'));



    % Naming the performance results of this strategy.
    resultName = strcat('strategy',num2str(strategyNo),'Performance');
    thisPerformance.strategyName = resultName; % Include the name information in the results table for future use. i.e. Labelling.
    % Saving the results for future use in 'results' folder. This mat file will be used in 'loadResults.m' script.
    save(strcat("results/",resultName), 'thisPerformance');

    % Plot cumulative returns, market cumulative returns, and market annualized volatility with dateticks
    % The plot starts from 295th trading day.
    % marketCumLogRet295 is basically marketIndex.cumLogRet assuming we start from i = 295
    marketCumLogRet295 = marketIndex.cumLogRet - marketIndex.cumLogRet(295);

    plot(dateList(295:end ) , thisPerformance.thisStrategy.cumLogRet(295:end) ,...
         dateList(295:end ) , marketIndex.sigma(295:end) *sqrt(252 )          ,...
         dateList(295:end ) , marketCumLogRet295(295:end)) ;
    datetick('x','yyyy-mm', 'keepticks', 'keeplimits')
    lgd = legend('QuantShare strategy cumulative return', 'Annualized market volatility', 'Market cumulative return')
    saveas(gcf, strcat('plots/strategy',num2str(strategyNo),'Plot.png'));


    disp("Program ends!")
    disp(datestr(now, 'HH:MM:SS')); % displays time

end

% function ends here.
